<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Golf Away!</title> <!-- Permanent game name -->
<link rel="icon" type="image/png" href="favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<style>
body { margin:0; overflow:hidden; background: linear-gradient(#87CEEB, #cdefff); font-family:'Fredoka One',sans-serif;}
#ui{position:absolute;top:10px;left:10px;font-size:32px;font-weight:700;}
#resetBtn{position:absolute;top:10px;right:10px;padding:8px 16px;font-size:16px;border:none;border-radius:6px;background:#FF6347;color:white;cursor:pointer;}
#resetBtn:hover{background:#E5533D;}
canvas{display:block;}
.outline-white{color:white;-webkit-text-stroke:1.25px black;}
.outline-green{color:#32CD32;-webkit-text-stroke:1.25px #006400;}
.outline-blue{color:#1E90FF;-webkit-text-stroke:1.25px #104E8B;}
.outline-red{color:red;-webkit-text-stroke:1.25px #8B0000;}
#popupOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.35);display:none;justify-content:center;align-items:center;z-index:1000;}
#popup{background:#bfefff;padding:40px 60px;border-radius:25px;text-align:center;border:6px solid #4aa3d9;box-shadow:0 10px 0 #4aa3d9;min-width:400px;}
#popup h2{margin:0 0 30px 0;font-size:40px;color:#104e8b;}
.popupButtons{display:flex;gap:20px;}
.popupBtn{flex:1;padding:15px;font-size:20px;border-radius:15px;border:4px solid #4aa3d9;background:#9edfff;cursor:pointer;font-family:'Fredoka One',sans-serif;color:#083c6b;transition:transform 0.1s;}
.popupBtn:hover{transform:scale(1.05);}
.popupBtn:active{transform:scale(0.95);}
</style>
</head>
<body>

<div id="ui">
<span id="level" class="outline-white">Golf Away!</span><br>
<span id="par" class="outline-white">Par: 0</span><br>
<span id="strokesLabel" class="outline-white">Strokes:</span>
<span id="strokes" class="outline-white">0</span>
</div>

<button id="resetBtn">Reset</button>
<canvas id="game"></canvas>

<div id="popupOverlay">
  <div id="popup">
    <h2 id="popupText">Level Complete!</h2>
    <div class="popupButtons">
      <button class="popupBtn" id="mainMenuBtn">Main Menu</button>
      <button class="popupBtn" id="nextLevelBtn">Next Level</button>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ========== LEVEL SYSTEM ==========
let currentLevel = 1;

const levels = {
    1: {
        name: "1-1 A Sloped Start",
        par: 3,
        terrain: function(x){
            const plateauHeight = canvas.height - 400;
            const plateauEnd = 300;
            const slopeEnd = canvas.width - 200;
            const flatHeight = canvas.height - 200;
            if(x <= plateauEnd) return plateauHeight;
            if(x <= slopeEnd){
                const t = (x - plateauEnd)/(slopeEnd - plateauEnd);
                return plateauHeight + t*(flatHeight - plateauHeight);
            }
            return flatHeight;
        }
    },
    2: {
        name: "1-2 Over a Hill",
        par: 4,
        terrain: function(x){
            const plateauHeight = canvas.height - 350;
            const plateauEnd = 200;

            const hillWidth = 400;
            const hillHeight = canvas.height - 500;

            const slopeWidth = 400;
            const rightHeight = canvas.height - 250;

            if(x <= plateauEnd) return plateauHeight;

            const hillStart = plateauEnd;
            const hillEnd = hillStart + hillWidth;
            const slopeStart = hillEnd;
            const slopeEnd = slopeStart + slopeWidth;

            if(x <= hillEnd){
                const t = (x - hillStart)/hillWidth;
                // smooth ascent to hill peak using half sine
                return plateauHeight - Math.sin(t * Math.PI/2)*(plateauHeight - hillHeight);
            } else if(x <= slopeEnd){
                const t = (x - slopeStart)/slopeWidth;
                // smooth descent from hill peak to right plateau using half sine
                return hillHeight + Math.sin(t * Math.PI/2)*(rightHeight - hillHeight);
            } else return rightHeight;
        }
    }
};

// ========== PHYSICS ==========
let strokes = 0;
let par = levels[currentLevel].par;

const gravity=0.4;
const airDrag=0.995;
const groundFriction=0.975;
const slopeGravityFactor=0.25;
const maxPower=18;
const stopThreshold=0.03;
const holeVelocityThreshold=4;
const holeOffset=50;

let ball={x:150,y:0,radius:14,color:"#FFF",vx:0,vy:0,grounded:true,moving:false};
let hole={x:canvas.width-150,radius:18};

const popupOverlay=document.getElementById("popupOverlay");
const popupText=document.getElementById("popupText");

// ========== UI FUNCTIONS ==========
function updateUIColor(){
    const parEl=document.getElementById("par");
    const strokesEl=document.getElementById("strokes");
    const strokesLabelEl=document.getElementById("strokesLabel");

    if(strokes<par){
        parEl.className="outline-green";
        strokesEl.className="outline-green";
        strokesLabelEl.className="outline-green";
    } else if(strokes===par){
        parEl.className="outline-blue";
        strokesEl.className="outline-blue";
        strokesLabelEl.className="outline-blue";
    } else {
        parEl.className="outline-red";
        strokesEl.className="outline-red";
        strokesLabelEl.className="outline-red";
    }
}

function showPopup(){
    popupText.textContent = strokes===1 ? "ðŸŒŸHole in one! ðŸŒŸ" : "â­ Level Complete! â­";
    popupOverlay.style.display="flex";
}

function hidePopup(){ popupOverlay.style.display="none"; }

// ========== TERRAIN ==========
function terrainHeight(x){ return levels[currentLevel].terrain(x); }
function getSlope(x){ const delta=1; return (terrainHeight(x+delta)-terrainHeight(x-delta))/(2*delta);}
function getSlopeAngle(x){ return Math.atan(getSlope(x)); }

// ========== RESET GAME ==========
function resetGame(){
    strokes = 0;
    document.getElementById("strokes").textContent = strokes;
    par = levels[currentLevel].par;
    document.getElementById("par").textContent = "Par: " + par;
    document.getElementById("level").textContent = levels[currentLevel].name;
    updateUIColor();

    ball.x = 150;
    ball.y = terrainHeight(ball.x)-ball.radius;
    ball.vx = 0; ball.vy = 0;
    ball.moving=false;
    ball.grounded=true;
}

// ========== INPUT ==========
let aiming=false, mouse={x:0,y:0};

canvas.addEventListener("mousedown",(e)=>{
    if(ball.moving) return;
    const dx=e.clientX-ball.x;
    const dy=e.clientY-ball.y;
    if(Math.sqrt(dx*dx+dy*dy)<ball.radius+5){ aiming=true; mouse.x=e.clientX; mouse.y=e.clientY; }
});
canvas.addEventListener("mousemove",(e)=>{ if(aiming) mouse={x:e.clientX,y:e.clientY}; });
canvas.addEventListener("mouseup",()=>{
    if(!aiming) return;
    let dx=ball.x-mouse.x;
    let dy=ball.y-mouse.y;
    let power=Math.min(Math.sqrt(dx*dx+dy*dy)*0.12,maxPower);
    let angle=Math.atan2(dy,dx);

    ball.vx=Math.cos(angle)*power;
    ball.vy=Math.sin(angle)*power;
    ball.moving=true;
    ball.grounded=false;

    strokes++; 
    document.getElementById("strokes").textContent=strokes;
    updateUIColor();

    aiming=false;
});

document.getElementById("resetBtn").onclick = resetGame;

// ========== NEXT LEVEL BUTTON ==========
document.getElementById("nextLevelBtn").onclick = () => {
    hidePopup();
    if(currentLevel < Object.keys(levels).length){
        currentLevel++;
        resetGame();
    } else {
        alert("You finished all levels!");
        currentLevel = 1;
        resetGame();
    }
};

document.getElementById("mainMenuBtn").onclick = () => { 
   currentLevel = 1; 
   resetGame(); 
};

// ========== PHYSICS UPDATE ==========
function updatePhysics(){
    if(!ball.moving) return;

    if(!ball.grounded) ball.vy += gravity;
    ball.vx *= airDrag; ball.vy *= airDrag;
    ball.x += ball.vx; ball.y += ball.vy;

    const groundY = terrainHeight(ball.x)-ball.radius;

    if(ball.y >= groundY){
        ball.y = groundY;
        ball.grounded = true;
        if(ball.vy>0) ball.vy=0;

        const slope = getSlope(ball.x);
        ball.vx += slope*slopeGravityFactor;
        if(Math.abs(slope)<0.02) ball.vx *= groundFriction;

        if(Math.abs(ball.vx)<stopThreshold && Math.abs(slope)<0.04){
            ball.vx=0; ball.moving=false;
        }
    } else ball.grounded=false;

    const holeCenterX = hole.x+holeOffset;
    const holeCenterY = terrainHeight(hole.x)-hole.radius;
    const dx = ball.x-holeCenterX;
    const dy = ball.y-holeCenterY;
    const distance = Math.sqrt(dx*dx + dy*dy);

    if(distance < hole.radius - ball.radius*0.3 && Math.abs(ball.vx)<=holeVelocityThreshold && ball.grounded){
        ball.vx=0; ball.vy=0;
        ball.moving=false; ball.grounded=true;
        showPopup();
    }
}

// ========== DRAW FUNCTIONS ==========
function drawTerrain(){
    ctx.fillStyle="#32CD32";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height);
    for(let x=0;x<=canvas.width;x++) ctx.lineTo(x,terrainHeight(x));
    ctx.lineTo(canvas.width,canvas.height);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle="#006400";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0,terrainHeight(0));
    for(let x=1;x<=canvas.width;x++) ctx.lineTo(x,terrainHeight(x));
    ctx.stroke();
}

function drawHole(){
    const holeCenterX = hole.x+holeOffset;
    const holeCenterY = terrainHeight(hole.x);
    const angle = getSlopeAngle(hole.x);

    ctx.save();
    ctx.translate(holeCenterX,holeCenterY);
    ctx.rotate(angle);

    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.moveTo(-hole.radius,0);
    ctx.arc(0,0,hole.radius,0,Math.PI,false);
    ctx.fill();

    ctx.strokeStyle="#808080";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.arc(0,0,hole.radius,0,Math.PI,false);
    ctx.stroke();

    ctx.strokeStyle="#FFF";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(0,-50);
    ctx.stroke();

    const side=25;
    const h=side*Math.sqrt(3)/2;
    ctx.fillStyle="#FF0000";
    ctx.strokeStyle="#000";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(0,-50);
    ctx.lineTo(side,-50+h/2);
    ctx.lineTo(0,-50+h);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.restore();
}

function drawBall(){
    ctx.fillStyle=ball.color;
    ctx.beginPath();
    ctx.arc(ball.x,ball.y,ball.radius,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="#000";
    ctx.lineWidth=3;
    ctx.stroke();
}

function drawAimArrows(){
    if(!aiming) return;
    const dx = mouse.x-ball.x;
    const dy = mouse.y-ball.y;
    const angle = Math.atan2(dy,dx)+Math.PI;
    const power = Math.min(Math.sqrt(dx*dx+dy*dy)*0.12,maxPower);
    const arrowCount = Math.max(1,Math.ceil((power/maxPower)*3));
    const startOffset = 30;
    const spacing = 35;

    ctx.strokeStyle="#FFF";
    ctx.lineWidth=3;
    ctx.lineCap="round";

    for(let i=0;i<arrowCount;i++){
        const length = startOffset+spacing*i;
        const arrowX = ball.x+Math.cos(angle)*length;
        const arrowY = ball.y+Math.sin(angle)*length;
        const size=12;

        ctx.beginPath();
        ctx.moveTo(arrowX-size*Math.cos(angle-Math.PI/6),arrowY-size*Math.sin(angle-Math.PI/6));
        ctx.lineTo(arrowX,arrowY);
        ctx.lineTo(arrowX-size*Math.cos(angle+Math.PI/6),arrowY-size*Math.sin(angle+Math.PI/6));
        ctx.stroke();
    }
}

// ========== GAME LOOP ==========
function gameLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    updatePhysics();
    drawTerrain();
    drawHole();
    drawBall();
    drawAimArrows();
    requestAnimationFrame(gameLoop);
}

resetGame();
gameLoop();
</script>

</body>
</html>
