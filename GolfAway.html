<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Golf Away!</title>
<link rel="icon" type="image/png" href="favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<style>
body { margin:0; overflow:hidden; background: linear-gradient(#87CEEB, #cdefff); font-family:'Fredoka One',sans-serif;}
#ui{position:absolute;top:10px;left:10px;font-size:32px;font-weight:700;pointer-events:none;}
canvas{display:block;}
.outline-white{color:white;-webkit-text-stroke:1.25px black;}
.outline-green{color:#32CD32;-webkit-text-stroke:1.25px #006400;}
.outline-blue{color:#1E90FF;-webkit-text-stroke:1.25px #104E8B;}
.outline-red{color:red;-webkit-text-stroke:1.25px #8B0000;}
#popupOverlay, #pauseOverlay{position:fixed; inset:0; backdrop-filter:blur(8px); background:rgba(0,0,0,0.35); display:none; justify-content:center; align-items:center; z-index:1000;}
#popup, #pauseMenu{background:rgba(0,0,0,0.85); padding:50px 70px; border-radius:20px; text-align:center; min-width:400px; box-shadow:0 10px 25px rgba(0,0,0,0.6);}
#popup h2,#pauseMenu h2{color:white; margin-bottom:35px; font-size:38px; font-weight:400;}
.popupButtons{display:flex;gap:20px; flex-direction: column;}
.popupBtn,.pauseBtn{display:block; width:100%; margin:10px 0; padding:15px; font-size:20px; border:none; border-radius:12px; cursor:pointer; font-family:'Fredoka One',sans-serif; font-weight:400; background:#444; color:white; transition:transform 0.1s, background 0.2s;}
.popupBtn:hover,.pauseBtn:hover{background:#666; transform:scale(1.05);}
.popupBtn:active,.pauseBtn:active{transform:scale(0.95);}
</style>
</head>
<body>
<div id="ui">
<span id="level" class="outline-white">Golf Away!</span><br>
<span id="par" class="outline-white">Par: 0</span><br>
<span id="strokesLabel" class="outline-white">Strokes:</span>
<span id="strokes" class="outline-white">0</span>
</div>
<canvas id="game"></canvas>
<div id="popupOverlay">
  <div id="popup">
    <h2 id="popupText">Level Complete!</h2>
    <div class="popupButtons">
      <button class="popupBtn" id="mainMenuBtn">Main Menu</button>
      <button class="popupBtn" id="nextLevelBtn">Next Level</button>
    </div>
  </div>
</div>
<div id="pauseOverlay">
  <div id="pauseMenu">
    <h2>Paused</h2>
    <button class="pauseBtn" id="continueBtn">Continue</button>
    <button class="pauseBtn" id="restartBtn">Restart</button>
    <button class="pauseBtn" id="pauseMainMenuBtn">Main Menu</button>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let currentLevel = 1;

const levels = {
  1: { name:"1-1 A Sloped Start", par:3, terrain:(x)=>{
      const plateauHeight = canvas.height - 400;
      const plateauEnd = 300;
      const slopeEnd = canvas.width - 200;
      const flatHeight = canvas.height - 200;
      if(x<=plateauEnd) return plateauHeight;
      if(x<=slopeEnd){ const t=(x-plateauEnd)/(slopeEnd-plateauEnd); return plateauHeight+t*(flatHeight-plateauHeight);}
      return flatHeight;
  }},
  2: { name:"1-2 Over a Hill", par:4, terrain:(x)=>{
      const verticalShift = 60;
      const plateauHeight = canvas.height - 350 + verticalShift;
      const hillPeakHeight = canvas.height - 520 + verticalShift;
      const hillWidth = 500;
      const center = canvas.width/2;
      const hillStart = center-hillWidth/2;
      const hillEnd = center+hillWidth/2;
      if(x<hillStart||x>hillEnd) return plateauHeight;
      const t = (x-hillStart)/hillWidth;
      return plateauHeight - Math.sin(t*Math.PI)*(plateauHeight-hillPeakHeight);
  }},
  3: {
    name:"1-3 Boarded Up",
    par:4,
    terrain:(x)=>{
      const topPlateau = canvas.height - 450;
      const topWidth = 250;
      const slopeWidth = 50;
      const lowerPlateau = canvas.height - 250;
      if(x <= topWidth) return topPlateau;
      if(x <= topWidth + slopeWidth){
          const t = (x - topWidth)/slopeWidth;
          return topPlateau + t*(lowerPlateau - topPlateau);
      }
      return lowerPlateau;
    },
    board: {
      x: 260,
      yTop: canvas.height - 480,
      yBottom: canvas.height - 570,
      width: 20,
      color:"#8B4513"
    }
  }
};

let strokes = 0;
let par = levels[currentLevel].par;
const gravity=0.4, airDrag=0.995, groundFriction=0.975, slopeGravityFactor=0.25;
const maxPower=16, stopThreshold=0.03, holeVelocityThreshold=4, holeOffset=50;

let ball={x:150,y:0,radius:14,color:"#FFF",vx:0,vy:0,grounded:true,moving:false};
let hole={x:canvas.width-150,radius:18};

const popupOverlay=document.getElementById("popupOverlay");
const popupText=document.getElementById("popupText");
let isPaused=false;

const pauseOverlay = document.getElementById("pauseOverlay");
function openPauseMenu(){ if(popupOverlay.style.display==="flex")return; isPaused=true; pauseOverlay.style.display="flex";}
function closePauseMenu(){ isPaused=false; pauseOverlay.style.display="none";}
document.addEventListener("keydown",(e)=>{if(e.key==="Escape"){if(!isPaused) openPauseMenu();}});
document.getElementById("continueBtn").onclick = closePauseMenu;
document.getElementById("restartBtn").onclick = ()=>{ closePauseMenu(); resetGame(); };
document.getElementById("pauseMainMenuBtn").onclick = ()=>{ closePauseMenu(); currentLevel=1; resetGame(); };

function updateUIColor(){
    const parEl=document.getElementById("par");
    const strokesEl=document.getElementById("strokes");
    const strokesLabelEl=document.getElementById("strokesLabel");
    if(strokes<par){ parEl.className="outline-green"; strokesEl.className="outline-green"; strokesLabelEl.className="outline-green";}
    else if(strokes===par){ parEl.className="outline-blue"; strokesEl.className="outline-blue"; strokesLabelEl.className="outline-blue";}
    else{ parEl.className="outline-red"; strokesEl.className="outline-red"; strokesLabelEl.className="outline-red";}
}

function showPopup(){ popupText.textContent=strokes===1?"ðŸŒŸ Hole in one! ðŸŒŸ":"â­ Level Complete! â­"; popupOverlay.style.display="flex";}
function hidePopup(){ popupOverlay.style.display="none"; }

function terrainHeight(x){ return levels[currentLevel].terrain(x);}
function getSlope(x){ const delta=1; return (terrainHeight(x+delta)-terrainHeight(x-delta))/(2*delta);}
function getSlopeAngle(x){ return Math.atan(getSlope(x)); }

function resetGame(){
    strokes=0; document.getElementById("strokes").textContent=strokes;
    par = levels[currentLevel].par; document.getElementById("par").textContent="Par: "+par;
    document.getElementById("level").textContent=levels[currentLevel].name; updateUIColor();
    ball.x = 150; ball.y = terrainHeight(ball.x)-ball.radius;
    ball.vx = 0; ball.vy = 0; ball.moving=false; ball.grounded=true;
}

let aiming=false, mouse={x:0,y:0};
canvas.addEventListener("mousedown",(e)=>{ if(ball.moving) return; const dx=e.clientX-ball.x; const dy=e.clientY-ball.y; if(Math.sqrt(dx*dx+dy*dy)<ball.radius+5){ aiming=true; mouse.x=e.clientX; mouse.y=e.clientY; }});
canvas.addEventListener("mousemove",(e)=>{ if(aiming) mouse={x:e.clientX,y:e.clientY};});
canvas.addEventListener("mouseup",()=>{
    if(!aiming) return;
    let dx=ball.x-mouse.x, dy=ball.y-mouse.y;
    let power=Math.min(Math.sqrt(dx*dx+dy*dy)*0.12,maxPower);
    let angle=Math.atan2(dy,dx);
    ball.vx=Math.cos(angle)*power; ball.vy=Math.sin(angle)*power;
    ball.moving=true; ball.grounded=false;
    strokes++; document.getElementById("strokes").textContent=strokes; updateUIColor();
    aiming=false;
});

document.getElementById("nextLevelBtn").onclick=()=>{ hidePopup(); if(currentLevel<Object.keys(levels).length){ currentLevel++; resetGame(); } else{ alert("You finished all levels!"); currentLevel=1; resetGame(); }};
document.getElementById("mainMenuBtn").onclick=()=>{ hidePopup(); currentLevel=1; resetGame(); };

function updatePhysics(){
    if(!ball.moving) return;
    if(!ball.grounded) ball.vy+=gravity;
    ball.vx*=airDrag; ball.vy*=airDrag;
    ball.x+=ball.vx; ball.y+=ball.vy;
    const groundY = terrainHeight(ball.x)-ball.radius;
    if(ball.y>=groundY){
        ball.y=groundY; ball.grounded=true;
        if(ball.vy>0) ball.vy=0;
        const slope = getSlope(ball.x);
        ball.vx+=slope*slopeGravityFactor;
        if(Math.abs(slope)<0.02) ball.vx*=groundFriction;
        if(Math.abs(ball.vx)<stopThreshold && Math.abs(slope)<0.04){ ball.vx=0; ball.moving=false;}
    } else ball.grounded=false;

    // Board collision (Level 3)
    if(currentLevel===3){
        const b = levels[3].board;
        if(ball.x + ball.radius > b.x && ball.x - ball.radius < b.x + b.width &&
           ball.y + ball.radius > b.yTop && ball.y - ball.radius < b.yBottom){
            // Ball hits top of the board
            if(ball.vy > 0 && ball.y < b.yTop){
                ball.y = b.yTop - ball.radius;
                ball.vy = 0;
                ball.vx += 1;
                ball.vy += 0.5;
                ball.moving = true;
                ball.grounded = false;
            }
        }
    }

    // Hole detection
    const holeCenterX = hole.x+holeOffset;
    const holeCenterY = terrainHeight(hole.x)-hole.radius;
    const dx = ball.x-holeCenterX, dy = ball.y-holeCenterY;
    const distance = Math.sqrt(dx*dx+dy*dy);
    if(distance<hole.radius-ball.radius*0.3 && Math.abs(ball.vx)<=holeVelocityThreshold && ball.grounded){
        ball.vx=0; ball.vy=0; ball.moving=false; ball.grounded=true;
        showPopup();
    }
}

function drawTerrain(){
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    for(let x=0;x<=canvas.width;x++) ctx.lineTo(x, terrainHeight(x));
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath();
    ctx.fillStyle="#32CD32";
    ctx.fill();
    ctx.strokeStyle="#006400";
    ctx.lineWidth=4;
    ctx.stroke();
}

function drawBoard(){
    if(currentLevel!==3) return;
    const b = levels[3].board;
    ctx.fillStyle=b.color; ctx.strokeStyle="#5C3317"; ctx.lineWidth=4;
    ctx.fillRect(b.x,b.yTop,b.width,b.yBottom-b.yTop);
    ctx.strokeRect(b.x,b.yTop,b.width,b.yBottom-b.yTop);
}

function drawHole(){
    const holeCenterX = hole.x+holeOffset;
    const holeCenterY = terrainHeight(hole.x);
    const angle = getSlopeAngle(hole.x);
    ctx.save(); ctx.translate(holeCenterX,holeCenterY); ctx.rotate(angle);
    ctx.fillStyle="black"; ctx.beginPath();
    ctx.moveTo(-hole.radius,0); ctx.arc(0,0,hole.radius,0,Math.PI,false); ctx.fill();
    ctx.strokeStyle="#808080"; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(0,0,hole.radius,0,Math.PI,false); ctx.stroke();
    ctx.strokeStyle="#FFF"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-50); ctx.stroke();
    const side=25; const h=side*Math.sqrt(3)/2;
    ctx.fillStyle="#FF0000"; ctx.strokeStyle="#000"; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,-50); ctx.lineTo(side,-50+h/2); ctx.lineTo(0,-50+h); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();
}

function drawBall(){ ctx.fillStyle=ball.color; ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.radius,0,Math.PI*2); ctx.fill(); ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.stroke(); }

function drawAimArrows(){ if(!aiming) return; const dx=mouse.x-ball.x; const dy=mouse.y-ball.y;
const angle=Math.atan2(dy,dx)+Math.PI; const power=Math.min(Math.sqrt(dx*dx+dy*dy)*0.12,maxPower);
const arrowCount = Math.max(1,Math.ceil((power/maxPower)*3)); const startOffset=50; const spacing=40; const chevronSize=20;
ctx.strokeStyle="#FFF"; ctx.lineWidth=3; ctx.lineCap="round";
for(let i=0;i<arrowCount;i++){ const length=startOffset+spacing*i; const tipX=ball.x+Math.cos(angle)*length; const tipY=ball.y+Math.sin(angle)*length;
ctx.beginPath(); ctx.moveTo(tipX-chevronSize*Math.cos(angle-Math.PI/6),tipY-chevronSize*Math.sin(angle-Math.PI/6));
ctx.lineTo(tipX,tipY); ctx.lineTo(tipX-chevronSize*Math.cos(angle+Math.PI/6),tipY-chevronSize*Math.sin(angle+Math.PI/6)); ctx.stroke();}}

function gameLoop(){ ctx.clearRect(0,0,canvas.width,canvas.height); if(!isPaused) updatePhysics(); drawTerrain(); drawBoard(); drawHole(); drawBall(); drawAimArrows(); requestAnimationFrame(gameLoop);}
resetGame(); gameLoop();
</script>
</body>
</html>
